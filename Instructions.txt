Hey Josh — great project. I went through the artifacts you attached and traced the rough spots back to specific places in the pipeline. Below is a concrete, code‑level review plus fixes.

---

## What I reviewed

Files you attached:

* `20197- TB December 2010.pdf`
* Markitdown output: `20197- TB December 2010.md`
* Mistral OCR output: `20197- TB December 2010_mistral_ocr.md`, `20197- TB December 2010_ocr_metadata.json`
* Hybrid report: `20197- TB December 2010_combined.md`
* Local table extractions:
  `…_tables.md`, `…_tables_all.md`, `…_tables_full.md`, `…_tables_wide.md`
* Log: `Log.txt`

---

## Executive summary

* **Mistral OCR did very well** on this PDF. It produced a clean **15‑column Trial Balance** with months from *Beginning Balance* through *Current Balance* and **\~58 rows** (see the large 15‑column table embedded in `…_mistral_ocr.md`).
* **Markitdown (non‑OCR) struggled**, which is expected for this kind of PDF. The main content in `…2010.md` is mostly unstructured text; tables weren’t recognized.
* **Local table extraction (pdfplumber/Camelot) failed open** and produced the “first‑column oddity” you noticed (account numbers/titles jammed together, e.g., `50530ElectricalR&M50532HVAC-WaterTreatment...`).
  Root causes:

  1. The PDF’s table isn’t easily recoverable by geometric table finders.
  2. A **bug in your `reshape_financial_table`** caused reshaping to abort, leaving the raw, messy table in place. The WARN lines you saw are real and relevant (details below).
* **Hybrid gating didn’t collapse the Markitdown section** even though OCR tables were good — a **regex edge case** in `_should_gate_markitdown` prevented it from triggering.

**Bottom line:** your code is close. Two small code fixes + one pipeline tweak will make Hybrid mode look great on documents like this:

1. Fix the Series “truth value is ambiguous” error in `reshape_financial_table`.
2. Relax the “grand total” regex so gating actually collapses Markitdown when OCR tables are strong.
3. Prefer **Mistral‑extracted tables** (you already have them in `…_ocr_metadata.json`) when local extractors are weak.

I’ve put precise diffs/patches below.

---

## How each output performed

### 1) Markitdown only (`20197- TB December 2010.md`)

* **Quality:** Low for this PDF. You mainly get paragraphs and scattered text. No reliably structured table. This is **not your code’s fault**; it’s the limit of running Markitdown on a laid‑out accounting PDF that needs OCR/layout‑aware parsing.

### 2) Mistral OCR (`…_mistral_ocr.md` and `…_ocr_metadata.json`)

* **Quality:** High. The big Trial Balance is recognized as a **15‑column table** (Acct/Account Title + Beginning Balance … December … Current Balance) with **\~58 rows**. This table is the one you want downstream.
* You’re already collecting structured signals in `extract_structured_content` (tables + rows). Good design.

### 3) Local tables (`…_tables_all.md`, `…_tables_full.md`, `…_tables_wide.md`)

* **Quality:** Low for this PDF. Camelot ultimately ran in **stream fallback** (your log shows: “Camelot extracted 2 tables using stream (fallback)”), which commonly concatenates columns when the ruling lines/spacing aren’t clear.
* Compounded by a **reshape bug** (see next section), your fallback left the “raw” stream output intact → hence the “first column oddity”.

### 4) Hybrid combined (`…_combined.md`)

* Good structure (Markitdown section, then local tables, then OCR).
* **Issue:** The “collapse Markitdown when OCR tables are good” feature didn’t trigger because the regex didn’t detect `GRAND TOTAL` inside a pipe‑table row.

---

## The WARN messages & the “first‑column oddity”

### The WARN you saw is real and fixable

In `local_converter.reshape_financial_table`, this block:

```py
split = ser.str.extract(r"^\s*(?P<_code>\d{3,10})\s*(?:-|–|—)?\s*(?P<_title>.+?)\s*$")
title_hit = ((split.get("_title") or ser[[]]).notna() & nonempty).sum() / max(1, nonempty.sum())
code_hit  = ((split.get("_code")  or ser[[]]).notna() & nonempty).sum() / max(1, nonempty.sum())
```

uses Python’s `or` with a **pandas Series**. That raises:

> `ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), ...`

When that exception is thrown, your `except` path logs a WARN and **returns the raw df**. That’s why your reshape didn’t run and the “Acct/Title” column remained jammed.

### Minimal, safe fix

Replace the `or` logic with an explicit presence check:

```diff
- title_hit = ((split.get("_title") or ser[[]]).notna() & nonempty).sum() / max(1, nonempty.sum())
- code_hit  = ((split.get("_code")  or ser[[]]).notna() & nonempty).sum() / max(1, nonempty.sum())
+ title_series = split["_title"] if "_title" in split else ser.copy()
+ code_series  = split["_code"]  if "_code"  in split else ser.copy()
+ title_hit = (title_series.notna() & nonempty).sum() / max(1, nonempty.sum())
+ code_hit  = (code_series.notna()  & nonempty).sum() / max(1, nonempty.sum())
```

While you’re there, take advantage of the smarter column normalizer you already wrote and currently don’t use:

```diff
- data[out_name] = _get_series_from_df(df, src).apply(normalize_amount)
+ data[out_name] = _normalize_amount_column(_get_series_from_df(df, src))
```

This improves handling of “1.031” (dot‑thousands OCR artifact) columns.

After this change, the reshaper won’t bail out, and you’ll have a better chance of getting separate **Acct** and **Account Title** columns when Camelot/pdfplumber do produce something usable.

---

## Hybrid gating didn’t collapse Markitdown — regex tweak

Your `_should_gate_markitdown` looks for:

```py
has_total = bool(re.search(r'^\s*(grand\s+total|total\s*\$)\b', ocr_content, re.I | re.M))
```

But in this file the line is inside a markdown table row (starts with a `|`), e.g.:

```
| GRAND TOTAL | …
```

The caret `^` anchors at the pipe, so your pattern misses it. Change the regex to allow the “grand total” phrase to appear **within a table row**:

```diff
- has_total = bool(re.search(r'^\s*(grand\s+total|total\s*\$)\b', ocr_content, re.IGNORECASE | re.MULTILINE))
+ has_total = bool(re.search(r'(?m)^\s*(?:\|.*)?(grand\s+total|total\s*\$)\b', ocr_content, re.IGNORECASE))
```

With this tweak, your **GATE\_MARKITDOWN\_WHEN\_OCR\_GOOD=true** will correctly collapse the long Markitdown text in `_combined.md` when OCR tables are present and sufficiently large (your 10+ row heuristic is fine).

---

## Prefer OCR tables when locals are weak (one small addition)

You’re already parsing OCR into a structured object (`extract_structured_content`). For PDFs like this, that’s a goldmine. Add a narrow utility to write a canonical table from the OCR JSON **when** local tables are empty/poor.

**New function (in `mistral_converter.py`):**

```py
def write_tables_from_ocr(response_json: dict, base_name: str) -> list[Path]:
    """
    Build canonical tables (md + csv) from OCR 'tables' payload.
    Fallback only when local extraction failed or is clearly weak.
    """
    from pathlib import Path
    from config import OUT_MD
    from utils import write_text, md_table, normalize_amount  # or _normalize_amount_column
    import pandas as pd
    written = []

    structured = extract_structured_content(response_json)
    if not structured.get('tables'):
        return written

    # Heuristic: pick the widest table that looks like the TB
    tb = max(structured['tables'], key=lambda t: len(t.get('columns', [])))
    cols = [c.strip() for c in tb['columns']]
    rows = [[c.strip() for c in r] for r in tb['rows']]

    df = pd.DataFrame(rows, columns=cols)

    # Map/fix common header variants from OCR
    def norm(s): return re.sub(r'[^a-z]', '', s.lower())
    canon = ["Acct", "Account Title", "Beginning Balance", "January", "February", "March",
             "April", "May", "June", "July", "August", "September", "October", "November",
             "December", "Current Balance"]

    remap = {}
    for c in df.columns:
        n = norm(c)
        if n.startswith('acct'):
            remap[c] = "Acct"
        elif 'account' in n and 'title' in n:
            remap[c] = "Account Title"
        elif 'beginning' in n and 'balance' in n:
            remap[c] = "Beginning Balance"
        elif 'current' in n and 'balance' in n:
            remap[c] = "Current Balance"
        else:
            for m in canon:
                if norm(m) in n:
                    remap[c] = m
                    break
    df = df.rename(columns=remap)

    # Ensure canonical order & presence
    for m in canon:
        if m not in df.columns:
            df[m] = ""
    df = df[canon]

    # Normalize amounts
    month_cols = [c for c in canon if c not in ("Acct", "Account Title")]
    for c in month_cols:
        df[c] = df[c].map(normalize_amount)

    # Drop junk rows
    keep = df["Account Title"].astype(str).str.strip().ne("")
    df = df[keep]
    if month_cols:
        empty_row = df[month_cols].astype(str).apply(lambda s: s.str.strip().eq("")).all(axis=1)
        df = df[~empty_row]

    md_path   = OUT_MD / f"{base_name}_tables_from_ocr.md"
    csv_path  = OUT_MD / f"{base_name}_tables_from_ocr.csv"
    write_text(md_path, "# Tables (from OCR)\n\n" + md_table(df) + "\n")
    try:
        df.to_csv(csv_path, index=False)
        written += [md_path, csv_path]
    except Exception:
        written += [md_path]
    return written
```

**Where to call it**

* In `process_mistral_response_enhanced(...)`, after you write `…_mistral_ocr.md`:

  * Option A (non‑intrusive): always write `…_tables_from_ocr.md/csv` alongside OCR output.
  * Option B (smarter): only write it if local table extraction produced nothing or if a quick quality heuristic fails (e.g., < 6 numeric month columns found).

Either way, in Hybrid’s `_combine_hybrid_results(...)`, prefer to show **“Extracted Tables (OCR)”** when available; fall back to local otherwise.

---

## Optional: make Camelot a little sturdier (when it *does* work)

When you do have vector lines, Camelot’s **lattice** mode is best. You already try lattice first, then stream. A couple of parameters often help:

```py
# in try_camelot_tables, lattice attempt:
tables = camelot.read_pdf(
    str(pdf_path), flavor="lattice", pages="all",
    line_scale=40,            # thicker ruling lines
    process_background=True,  # pick up faint lines
)

# in the stream fallback, consider stricter tolerances to avoid merges:
tables = camelot.read_pdf(
    str(pdf_path), flavor="stream", pages="all",
    edge_tol=50, row_tol=6, column_tol=6, strip_text=" \n\t",
)
```

These won’t fix image‑based PDFs, but they reduce “column merging” on borderline vector tables.

---

## Small quality nits you can take or leave

* **Reading‑time estimate:** in `create_enhanced_markitdown_output`, consider `math.ceil(words / 200)` rather than `round` to avoid undercounting.
* **Image link rewriting:** your `rewrite_markitdown_image_links` is solid; just be sure to also handle `.gif`/`.webp` if you expect those (you already include webp, good).

---

## Quick patches you can drop in

### 1) Fix the Series “ambiguous truth value” (and use column normalizer)

**File:** `local_converter.py` (inside `reshape_financial_table`)

```diff
-            split = ser.str.extract(r"^\s*(?P<_code>\d{3,10})\s*(?:-|–|—)?\s*(?P<_title>.+?)\s*$")
-            title_hit = ((split.get("_title") or ser[[]]).notna() & nonempty).sum() / max(1, nonempty.sum())
-            code_hit  = ((split.get("_code")  or ser[[]]).notna() & nonempty).sum() / max(1, nonempty.sum())
+            split = ser.str.extract(r"^\s*(?P<_code>\d{3,10})\s*(?:-|–|—)?\s*(?P<_title>.+?)\s*$")
+            title_series = split["_title"] if "_title" in split else ser.copy()
+            code_series  = split["_code"]  if "_code"  in split else ser.copy()
+            title_hit = (title_series.notna() & nonempty).sum() / max(1, nonempty.sum())
+            code_hit  = (code_series.notna()  & nonempty).sum() / max(1, nonempty.sum())

-                    # Normalize amount columns
-                    data[out_name] = _get_series_from_df(df, src).apply(normalize_amount)
+                    # Normalize amount columns (column-aware)
+                    data[out_name] = _normalize_amount_column(_get_series_from_df(df, src))
```

### 2) Make gating detect totals inside a table row

**File:** `main.py` (actually `_should_gate_markitdown` is in `main.py`)

```diff
-        has_total = bool(re.search(r'^\s*(grand\s+total|total\s*\$)\b', ocr_content,
-                                   re.IGNORECASE | re.MULTILINE))
+        has_total = bool(re.search(r'(?m)^\s*(?:\|.*)?(grand\s+total|total\s*\$)\b',
+                                   ocr_content, re.IGNORECASE))
```

### 3) (Optional but recommended) Emit canonical tables directly from OCR

**File:** `mistral_converter.py`

Add the `write_tables_from_ocr(...)` function shown above, and call it at the end of `process_mistral_response_enhanced(...)`:

```diff
     ocr_md_path = OUT_MD / f"{base_name}_mistral_ocr.md"
     write_text(ocr_md_path, enhanced_md)
     structured = extract_structured_content(response_json)
     if structured['text_blocks'] or structured['images']:
         metadata_path = OUT_MD / f"{base_name}_ocr_metadata.json"
         write_text(metadata_path, json.dumps(structured, indent=2, default=str))
         logline(f"  -> Saved structured metadata: {metadata_path.name}")
     logline(f"  -> Enhanced OCR output: {ocr_md_path.name}")
+
+    # New: write canonical tables from OCR (helps when local table extraction is weak)
+    try:
+        written = write_tables_from_ocr(response_json, base_name)
+        if written:
+            logline(f"  -> Wrote OCR-derived tables: {[p.name for p in written]}")
+    except Exception as e:
+        logline(f"  -> WARN: Could not write OCR-derived tables: {e}")
```

Then, in your Hybrid combiner, prefer these `*_tables_from_ocr.*` artifacts when present.

---

## Environment / settings notes

* Your `.env.example` and bootstrapping scripts look good. For PDFs like this, Hybrid mode is the right default.
* Markitdown’s `pdf_mode=auto` is fine here — the key is that **Mistral OCR** becomes your “source of truth” for tables.

---

## Verdict for this document

* **Best available table:** the **Mistral OCR table** in `20197- TB December 2010_mistral_ocr.md` (and its JSON representation).
* **What caused the first‑column oddity?**
  Mainly: (a) the document is hard for geometric table extraction, and (b) your `reshape_financial_table` hit a Series truthiness bug and bypassed the reshaping logic.
* **Are fixes needed?** Yes — the two tiny code changes above plus (optionally) emitting tables straight from OCR. After that:

  * Hybrid will **collapse Markitdown** when OCR tables are good.
  * You’ll **avoid the first‑column oddity**, even when Camelot/pdfplumber struggle, because you’ll fall back to OCR tables.

If you’d like, I can produce a small PR‑style patch bundle and show where in `_combine_hybrid_results` to splice in the OCR‑table preference.
